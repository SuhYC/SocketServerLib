# IOCP 버전
개발기간 : 2025.07.07 ~ 2025.07.09 <br/>

### 재시도큐
굳이 수신로직과 작업처리로직을 분리해야겠다는 생각을 하게 만든 주범. <br/>
L7의 송신버퍼가 가득차서 송신이 실패하는 경우를 생각해서 반환코드에서 버퍼상태를 확인하고 재시도할 수 있게 만들었다. <br/>
버퍼문제로 송신이 실패했다면 작업객체를 다시 작업큐에 넣어 나중에 재시도할 수 있도록 했다. <br/>

### 스핀락과 RAII
간단하게 atomic_bool을 사용하여 구현하였다. <br/>
뮤텍스와 마찬가지로 중복호출로 인해 발생하는 데드락은 방지하지 않았다. 사용 시 주의. <br/>
RAII 패턴을 적용하여 스핀락가드를 만들어 두었다. <br/>
std::lock_guard와 동일하게 SpinLock객체를 받아 RAII로직을 적용할 수 있다. <br/>
별도의 API는 없음. 생성자를 통해 락을 얻고 소멸자를 통해 락을 해제한다. <br/>

### 팩토리 패턴과 의존성 주입
작업을 처리하는데 필요한 객체들을 작업에 의존성객체로 넘긴다. <br/>
기본적으로 UserManager와 ZoneManager, PacketPool을 의존성 객체로 넘기게 해두었다. <br/>
DIStruct를 수정하여 어떤 의존성 객체를 넘길지는 자유. <br/>

팩토리에 수신한 메시지를 넘기면 헤더파싱을 통해 어떤 요청번호로 온 메시지인지 파악한다. <br/>
이후 요청번호에 맞는 작업객체 할당함수를 호출한다. <br/>
이 할당함수는 JobFactory::Init 함수에서 Register함수를 호출하여 바인딩한다. <br/>

### 메모리풀
작업객체는 요청에 따라 크기가 달라질 수 있다. <br/>
파라미터의 크기가 다를 수 있기 때문. <br/>
작업객체를 생성하는 JobFactory에서 Job객체를 할당할 때, <br/>
동적할당을 수행하는 것보다 미리 메모리블럭을 많이 생성해두고 가져와 생성자만 호출해서 쓰는 방식을 선택하기로 한다. <br/>
Job의 파생클래스 중 가장 큰 크기를 기준으로 메모리블럭을 생성하여 다양한 객체에 대응할 수 있도록 한다. <br/>
가장 큰 크기는 union을 이용해서 구하기로 한다. <br/>
파생클래스의 객체를 전부 union 내부에 둔다면, union은 자동으로 해당 객체들 중 가장 큰 크기에 맞추게 되어있는걸 이용. <br/>
이후 템플릿함수에서 placement new를 이용해 원하는 객체의 생성자를 호출하여 반환하도록 한다. <br/>

### Zero-Copy
최대한 복사연산을 적게 시도할 수 있도록 로직 사이사이에 불필요한 복사를 차단했다. <br/>
기존 방식에서는 <br/>
1. 수신버퍼에서 슬라이드버퍼로 복사
2. 슬라이드버퍼에서 메시지단위로 쪼개 메시지버퍼로 복사
3. 메시지버퍼에서 작업객체에 파라미터구조체로 복사
4. 작업을 처리한 결과를 직렬화버퍼에 직렬화하면서 복사
5. 직렬화버퍼를 패킷객체에 복사
6. 패킷객체에서 송신 슬라이드버퍼로 복사
7. 송신 슬라이드 버퍼에서 전송중인 버퍼로 복사 (커널꺼가 아니고 L7)
이런 식이었는데, 이를 다음과 같이 개선했다. <br/>
1. 수신버퍼에서 슬라이드버퍼로 복사
2. 슬라이드버퍼의 내용을 참조로 넘겨 바로 작업팩토리의 함수를 호출하여 작업객체의 파라미터 구조체로 복사
3. 작업 처리 결과를 구조체로 작성하여 바로 패킷객체에 복사
4. 패킷객체에서 송신 슬라이드버퍼로 복사 후 송신IO 수행

3단계를 줄였다. <br/>
기존방식의 2~3 단계를 통합하기 위해 std::string_view를 활용하였고, <br/>
4~5단계를 통합하기 위해 패킷객체에 직접 POD 복사하는 방식으로 직렬화를 변경했다. (기존방식은 필드별 직렬화) <br/>
6~7단계를 통합하기 위해 1-send 송신중확인 로직을 WSABUF.len을 확인하는 방식으로 변경. <br/>

패킷 객체를 슬라이드버퍼로 복사하지 않고 그대로 큐에 저장해뒀다가 송신하는 방법도 생각해봤으나 <br/>
슬라이드버퍼의 목적이 자잘한 메시지는 병합하여 보낼 수 있게 하는거라 기각. <br/>

사실 std::string_view를 직접쓰지 않고도 포인터와 크기를 넘기는 걸로 충분하긴 한데 <br/>
파라미터가 길어지는게 별로 보기 좋지 않은거 같아서 사용. <br/>

### 슬라이드버퍼
링버퍼 혹은 슬라이드버퍼를 L7의 버퍼로 사용하는 경우 <br/>
자잘한 데이터를 병합하여 송신함으로서 헤더낭비를 줄이고 송수신 효율을 향상시키는 효과가 있다. <br/>
Nagle옵션과 차이점은 언제까지 버퍼링하느냐. <br/>
Nagle은 클라이언트가 수신하여 ACK를 전송하고 다시 서버가 ACK를 수신하는 시점까지 버퍼링된다. <br/>
하지만 L7버퍼는 커널의 송신버퍼로 옮겨담는게 완료되는 시점까지 버퍼링된다. <br/>
즉, Nagle 옵션을 켜면 RTT 이상의 딜레이가 발생할 수 있다는 의미이고, <br/>
Nagle옵션을 끄고 L7버퍼를 사용하는건 RTT를 기다리지 않고 순서를 보장하는 한에 할 수 있는 동작을 모두 수행할 수 있다는 것이다.

## 로그 출력 클래스와 매크로함수
딱히 기술적으로 뛰어난건 없는데 출력레벨 때문에 유심히 볼까봐 설명 작성. <br/>
DEBUG레벨의 위험도를 확인하고 싶지 않을수도 있으니 ERR레벨의 로그만 확인하는 등의 출력레벨 조정이 가능. <br/>
멀티스레드 환경에서 표준출력을 그냥 사용하면 자꾸 메시지가 겹치는 경우가 생겨서 내부적으로 락을 사용. <br/>
다중인자를 받을 수 있게 템플릿 함수로 만들어서 편하게 ,로 구분해서 넣으면 된다. <br/>

Define헤더에 매크로함수 몇개를 적어놨다. <br/>
try-catch문의 마지막에 std::exception& 타입과 ... 예외캐치를 일일히 적는게 귀찮아서 작성한 디폴트캐치. <br/>
디폴트캐치는 별도의 조기반환 없이 로그만 찍고 그냥 진행한다. 함수의 반환타입 문제 때문에 그렇게 작성. <br/>
로그 출력 함수를 매크로함수로 작성해뒀다. <br/>
enum자체가 2개밖에 없는데 타이핑할게 많아서 귀찮기도 했고, <br/>
디버깅할때 어떤 객체의 어떤 함수에서 에러가 발생했는지 일일히 적기 귀찮아서 <br/>
__FUNCSIG__로 함수시그니처를 받아와서 문자열로 만들어 인자로 넘기는 기능을 매크로화했다. <br/>

## 사용법
1. Define 헤더에서 ReqType에 새로운 enum을 생성하고 LAST = 부분에 새로 작성한 enum 등록
2. 요청에 쓰는 파라미터를 POD형태로 작성.
3. Job클래스를 상속하는 파생클래스로 해당 요청에 대한 정의 작성. 파라미터 구조체도 멤버에 포함
4. JobMemoryPool 헤더의 Jobs 유니온에 해당 파생클래스 추가. (가장 큰 Job파생객체 크기를 파악하기 위함)
5. JobFactory::Init 함수에 요청코드와 파생클래스를 인자로 Register함수 호출

## 비고
일단 EchoJob으로 예시가 작성되어있다. <br/>
IOCP버전은 추후에도 내가 계속 쓸거 같아서 이것저것 넣어둔게 많다. <br/>
메모리풀이라던지 객체풀이라던지 로그 출력 클래스나 스핀락, 재시도큐, Zero-Copy, 매크로 함수, 팩토리 패턴과 의존성 주입 등등.. <br/>
다른 버전에서는 귀찮으면 소폭 간단한 방식으로 떼울 가능성 높음.
