# SelectAPI on Windows
## 윈도우즈 셀렉트 API 서버
일단 감시형 서버 경험을 위해 빠르게 제작. <br/>
리눅스와 조금 차이가 있다. <br/>

## 감시형 서버
감시할 소켓의 목록을 작성하여, <br/>
수신할 메시지가 있는 소켓, 커널버퍼가 여유있는 상태인 소켓, 예외가 발생한 소켓의 수를 조회할 수 있는 api를 제공한다. <br/>
```select(int maxfd, fd_set* readset, fd_set* writeset, fd_set* exceptset, const struct timeval* timeout)```와 같은 형태로 호출하며, <br/>
리눅스에서는 ```maxfd```에 감시할 파일디스크립터의 수를 명시하여야 하며, <br/>
윈도우즈에서는 일반적인 상황에서 ```maxfd```를 0으로 둬도 문제가 없다. (문제가 생기는 경우는 아래 후술한다.) <Br/>

## select 호출과 fd_set 구조체
```select```를 호출하면 ```fd_set```구조체 내에서 io가 가능한 소켓만 남기고 모두 제거한다. <br/>
그러므로 ```select```호출 직전에 복사하여 만든 구조체를 넘기거나, 새로운 구조체에 초기화 후 넘기는 게 좋다. <br/>

## 함수
```FD_ZERO(fd_set* fdset)``` : 구조체를 영초기화한다. <br/>
```FD_SET(int fd, fd_set* fdset)``` : 구조체에 핸들/파일디스크립터를 삽입한다. <br/>
```FD_CLR(int fd, fd_set* fdset)``` : 구조체에서 핸들/파일디스크립터를 제거한다. <br/>
```FD_ISSET(int fd, fd_set* fdset)``` : 구조체에서 fd의 변경사항이 있으면 양수를 반환한다. <br/>

초기 상태에서 ```FD_ZERO```함수로 구조체를 초기화하고, <br/>
새로 발급된 핸들/파일디스크립터를 ```FD_SET```함수로 ```fd_set``` 구조체에 추가하고, <br/>
더 이상 io하지 않을 핸들/파일디스크립터를 ```FD_CLR```로 제거하고, <br/>
```select```를 호출하여 변경된 소켓이 1개 이상인 경우에 소켓들을 순회하며 ```FD_ISSET```함수로 확인하고 확인된 소켓에서 IO처리를 하면 된다. <br/>

## fd_set에서 관리하는 법
리눅스는 소켓발급시 파일디스크립터가 0부터 할당되어 차례대로 넘버링된다. <br/>
하지만 윈도우즈는 소켓핸들이 0번부터라는 보장도 없으면 차례대로라는 보장도 없는 임의의 값이 배정될 수 있다. <br/>
fd_set의 정보를 조회할 때도 리눅스는 i번째 인덱스에 대해 ```FD_ISSET(i, &cpy_reads)```와 같은 식으로 조회할 수 있으며 i를 그대로 소켓으로 생각하고 조작할 수 있지만, <Br/>
윈도우즈는 소켓핸들이 i가 아닐 수 있으므로 ```reads.fd_array[i]```와 같이 인덱스에 매핑된 소켓핸들을 찾아 사용하여야한다. <br/>

## write_fd_set을 감시할 때 주의사항
기본적으로 커널버퍼가 송신가능한 상태인지 확인하기 위해 writes로 fd_set을 관리하여 select요청할 때, <Br/>
```select(0, 0, &writes, 0, &timeout)```과 같이 호출하는 경우 fd_set에 소켓이 없으면 ```SOCKET_ERROR```를 반환한다. <br/>
```WSAGetLastError()```로 확인해보면 10022. 잘못된 인자를 넣었다고 에러가 뜨는데, <br/>
이를 우회하는 방법으로 fd_count가 0일 때는 select를 호출하지 않도록 하면 된다. <br/>
```reads```셋을 감시하는 경우에도 비슷한 에러가 발생할 수도 있으나, 보통 listenSocket이 항상 있는 상태로 호출하기 때문에 보기 드물다. <br/>
