# Epoll
리눅스 Epoll버전의 에코서버도 제작해보았다. <br/>
일단 레벨트리거 방식으로 작성.

## 레벨트리거 (LT)
커널버퍼에 아직 수신할 데이터가 있다면 epoll이벤트로 재등록되는 방식. <Br/>
read를 호출했더라도 잔여메시지가 남아있다면 다시 이벤트로 통지된다. <br/>

## 엣지트리거 (ET)
새로운 커널단위 수신이 발생했을 때만 통지한다. <br/>
read를 호출했을 때 잔여메시지가 남아있더라도 이벤트로 재등록되지 않고, 버퍼가 비어있던 상태에서 다음 수신이 발생했을 때만 이벤트로 통지된다. <br/>
epoll관련 함수가 애플리케이션영역 <-> 커널영역을 모두 거쳐야하는 것을 생각하면 레벨트리거에 비해 오버헤드를 줄일 수 있다. <br/>
```
LT : {check, read} * n
ET : check * 1 + {read} * n
```

또한 수신시점과 처리시점을 분리할 수 있다는 장점이 있다. <br/>
다수의 클라이언트로부터 정보를 받아 조합해야하는 케이스에서 임의의 클라이언트가 연결되지 않아 지연될 때, 나머지 클라이언트의 데이터를 일부러 수신해서 L7에서 보관할 필요는 없다는 것이다. <br/>

엣지트리거 방식의 구현을 시도할 경우 반드시 논블로킹 소켓으로 설정해야한다. <br/>

## 관련함수
```int epoll_create(int)``` : epoll_fd를 발급하는 함수. 매개변수는 epoll인스턴스의 크기를 결정하는데, 리눅스 2.6.8이상에서는 의미없다. 커널 내에서 상황에 맞게 조절하기 때문. <br/>
```int epoll_ctl(int, int, int, epoll_event*)``` : 커널의 epoll인스턴스에 변경사항을 전달하는 함수. <br/>
두번째 인자에 EPOLL_CTL_ADD로 새로운 fd를 감시하도록 요청할 수도 있고, <br/>
EPOLL_CTL_MOD로 기존 감시하던 fd를 다른 형태로 감시하도록 요청할 수도 있고, <br/>
EPOLL_CTL_DEL로 기존 감시하던 fd를 감시하지 않도록 요청할 수도 있다. <br/>
네번째 인자로 전달되는 epoll_event는 epoll_event::events에 비트마스킹으로 EPOLLIN, EPOLLOUT, EPOLLERR 등의 감시요소를 지정할 수 있다. EPOLL_CTL_DEL의 경우는 당연히 NULL로 적으면 된다.<br/>
```int epoll_wait(int, epoll_event*, int, int)``` : 커널의 epoll인스턴스에서 발생한 이벤트를 수신하는 함수. <br/>
반환값은 발생한 이벤트의 수이다. <br/>
두번째 인자로 넣은 epoll_event배열에 발생한 이벤트의 정보가 담기며, 이를 처리하면 된다. <br/>
통지되는 event는 epoll_ctl로 넘겼던 event와 다르다. (포인터로 넘기기는 하나 내부적으로 복사로 처리된다)
